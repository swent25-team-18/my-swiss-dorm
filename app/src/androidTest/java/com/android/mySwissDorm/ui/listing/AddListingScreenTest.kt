package com.android.mySwissDorm.ui.listing

import androidx.activity.ComponentActivity
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.assertIsEnabled
import androidx.compose.ui.test.assertIsNotEnabled
import androidx.compose.ui.test.hasSetTextAction
import androidx.compose.ui.test.hasTestTag
import androidx.compose.ui.test.isDisplayed
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithTag
import androidx.compose.ui.test.performClick
import androidx.compose.ui.test.performScrollTo
import androidx.compose.ui.test.performTextInput
import androidx.core.net.toUri
import androidx.test.platform.app.InstrumentationRegistry
import com.android.mySwissDorm.model.map.Location
import com.android.mySwissDorm.model.photo.Photo
import com.android.mySwissDorm.model.photo.PhotoRepositoryProvider
import com.android.mySwissDorm.model.rental.RentalListingRepositoryFirestore
import com.android.mySwissDorm.model.rental.RentalListingRepositoryProvider
import com.android.mySwissDorm.model.residency.ResidenciesRepositoryFirestore
import com.android.mySwissDorm.model.residency.ResidenciesRepositoryProvider
import com.android.mySwissDorm.model.residency.Residency
import com.android.mySwissDorm.resources.C
import com.android.mySwissDorm.utils.FakePhotoRepository
import com.android.mySwissDorm.utils.FakePhotoRepository.Companion.FAKE_FILE_NAME
import com.android.mySwissDorm.utils.FakePhotoRepository.Companion.FAKE_NAME
import com.android.mySwissDorm.utils.FakePhotoRepository.Companion.FAKE_SUFFIX
import com.android.mySwissDorm.utils.FakeUser
import com.android.mySwissDorm.utils.FirebaseEmulator
import com.android.mySwissDorm.utils.FirestoreTest
import java.io.File
import java.net.URL
import kotlinx.coroutines.delay
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.test.runTest
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Assert.assertNotNull
import org.junit.Before
import org.junit.Rule
import org.junit.Test

/**
 * Tests focused on the AddListingScreen UI with the new centralized InputSanitizers. We verify: (1)
 * button enablement, (2) inline error for size format, (3) Firestore write.
 */
class AddListingScreenTest : FirestoreTest() {
  @get:Rule val composeRule = createAndroidComposeRule<ComponentActivity>()

  override fun createRepositories() {
    PhotoRepositoryProvider.initialize(InstrumentationRegistry.getInstrumentation().context)
    RentalListingRepositoryProvider.repository =
        RentalListingRepositoryFirestore(FirebaseEmulator.firestore)
    ResidenciesRepositoryProvider.repository =
        ResidenciesRepositoryFirestore(FirebaseEmulator.firestore)
  }

  private fun setContentWith(onConfirmCapture: (String) -> Unit = {}) {
    composeRule.setContent {
      AddListingScreen(
          onConfirm = { added -> onConfirmCapture(added.uid) }, onBack = { /* no-op */})
    }
  }

  private fun setContentWithViewModel(
      vm: AddListingViewModel,
      onConfirmCapture: (String) -> Unit = {}
  ) {
    composeRule.setContent {
      AddListingScreen(
          onConfirm = { added -> onConfirmCapture(added.uid) },
          onBack = { /* no-op */},
          addListingViewModel = vm)
    }
  }

  private fun createViewModelWithPhoto(): AddListingViewModel {
    val photo = Photo(File.createTempFile(FAKE_NAME, FAKE_SUFFIX).toUri(), FAKE_FILE_NAME)
    val fakeLocalRepo = FakePhotoRepository.commonLocalRepo({ photo }, {}, true)
    val vm = AddListingViewModel(photoRepositoryLocal = fakeLocalRepo)
    runBlocking {
      vm.addPhoto(photo)
      // Wait for the photo to be added to the state using real delays
      // This is more reliable in CI than test dispatcher advancement
      var attempts = 0
      while (vm.uiState.value.pickedImages.isEmpty() && attempts < 100) {
        delay(50)
        attempts++
      }
    }
    return vm
  }

  // generated by AI
  @Before
  override fun setUp() {
    runTest {
      super.setUp()
      switchToUser(FakeUser.FakeUser1)
      ResidenciesRepositoryProvider.repository.addResidency(
          Residency(
              name = "Vortex",
              description = "Test residency",
              location = Location(name = "Vortex", latitude = 46.52, longitude = 6.57),
              city = "Lausanne",
              email = null,
              phone = null,
              website = URL("https://example.com")))

      // Seed Private Accommodation so we can test the custom-location path
      ResidenciesRepositoryProvider.repository.addResidency(
          Residency(
              name = "Private Accommodation",
              description = "Private flat",
              location = Location(name = "Lausanne centre", latitude = 46.52, longitude = 6.63),
              city = "Lausanne",
              email = null,
              phone = null,
              website = null))

      // Wait for the residencies to be persisted to Firestore
      delay(500)
    }
  }

  // Helper function to select a residency from the dropdown
  private fun selectResidency(residencyName: String) {
    // Wait for the dropdown box to appear
    composeRule.waitUntil(5_000) {
      composeRule
          .onAllNodes(
              hasTestTag(C.SanitizedResidencyDropdownTags.RESIDENCY_DROPDOWN_BOX),
              useUnmergedTree = true)
          .fetchSemanticsNodes()
          .isNotEmpty()
    }

    // Click on the dropdown box to open the menu
    composeRule
        .onNodeWithTag(
            C.SanitizedResidencyDropdownTags.RESIDENCY_DROPDOWN_BOX, useUnmergedTree = true)
        .performClick()
    composeRule.waitForIdle()

    // Determine the test tag based on residency name
    val testTag =
        if (residencyName == "Private Accommodation") {
          C.SanitizedResidencyDropdownTags.PRIVATE_ACCOMMODATION
        } else {
          C.SanitizedResidencyDropdownTags.getResidencyTag(residencyName)
        }

    // Wait for the residency menu item to appear and click it
    composeRule.waitUntil(5_000) {
      composeRule
          .onAllNodes(hasTestTag(testTag), useUnmergedTree = true)
          .fetchSemanticsNodes()
          .isNotEmpty()
    }

    composeRule.onNodeWithTag(testTag, useUnmergedTree = true).performClick()
    composeRule.waitForIdle()
  }

  @After
  override fun tearDown() {
    super.tearDown()
  }

  @Test
  fun ui_button_disabled_until_all_fields_valid_then_writes() = run {
    runTest { switchToUser(FakeUser.FakeUser1) }
    var capturedUid: String? = null
    val vm = createViewModelWithPhoto()
    setContentWithViewModel(vm) { uid -> capturedUid = uid }

    // Wait for the ViewModel to initialize and photo to be reflected in UI
    composeRule.waitUntil(5_000) { vm.uiState.value.pickedImages.isNotEmpty() }
    composeRule.waitForIdle()

    val confirmBtn =
        composeRule
            .onNodeWithTag(C.AddListingScreenTags.CONFIRM_BUTTON, useUnmergedTree = true)
            .assertExists()
    confirmBtn.assertIsNotEnabled()

    // Fill fields with VALID values respecting new validators (size requires one decimal).
    composeRule
        .onNode(
            hasTestTag(C.AddListingScreenTags.TITLE_FIELD) and hasSetTextAction(),
            useUnmergedTree = true)
        .performTextInput("Cozy studio")
    selectResidency("Vortex")
    composeRule
        .onNode(
            hasTestTag(C.AddListingScreenTags.SIZE_FIELD) and hasSetTextAction(),
            useUnmergedTree = true)
        .performTextInput("25.0")
    composeRule
        .onNode(
            hasTestTag(C.AddListingScreenTags.PRICE_FIELD) and hasSetTextAction(),
            useUnmergedTree = true)
        .performTextInput("1200")
    composeRule
        .onNode(
            hasTestTag(C.AddListingScreenTags.DESC_FIELD) and hasSetTextAction(),
            useUnmergedTree = true)
        .performTextInput("Near EPFL")

    // Wait for form validation to update
    composeRule.waitForIdle()

    // Button should now enable
    confirmBtn.assertIsEnabled()
    confirmBtn.performClick()

    // Wait for the submission to complete and onConfirm to be called
    // The ViewModel's submitForm runs in a coroutine, so we need to wait for it
    composeRule.waitUntil(timeoutMillis = 10_000) { capturedUid != null }

    runTest {
      assertEquals("UI should insert one listing into Firestore", 1, getRentalListingCount())
    }
    assertNotNull("onConfirm must be called with the created listing", capturedUid)
  }

  @Test
  fun ui_inline_error_shown_for_size_without_decimal_and_blocks_submit() = run {
    runTest { switchToUser(FakeUser.FakeUser2) }
    setContentWith {}

    val confirmBtn =
        composeRule
            .onNodeWithTag(C.AddListingScreenTags.CONFIRM_BUTTON, useUnmergedTree = true)
            .assertExists()

    composeRule
        .onNode(
            hasTestTag(C.AddListingScreenTags.TITLE_FIELD) and hasSetTextAction(),
            useUnmergedTree = true)
        .performTextInput("X")
    composeRule
        .onNode(
            hasTestTag(C.AddListingScreenTags.DESC_FIELD) and hasSetTextAction(),
            useUnmergedTree = true)
        .performTextInput("Y")

    // Entering 1000 (no decimal) is invalid per validateFinal (must have exactly one decimal)
    composeRule
        .onNode(
            hasTestTag(C.AddListingScreenTags.SIZE_FIELD) and hasSetTextAction(),
            useUnmergedTree = true)
        .performTextInput("1000")

    // Price is fine but we keep it blank to ensure the button remains disabled
    // (even with price filled size error must still block submit)
    confirmBtn.assertIsNotEnabled()

    runTest { assertEquals(0, getRentalListingCount()) }
  }

  @Test
  fun ui_price_typing_filters_to_digits_and_caps_value_visually() = run {
    runTest { switchToUser(FakeUser.FakeUser1) }
    val vm = createViewModelWithPhoto()
    setContentWithViewModel(vm) {}

    // Enter noisy input; sanitizer should filter to digits only and drop leading zeros.
    val priceNode =
        composeRule.onNode(
            hasTestTag(C.AddListingScreenTags.PRICE_FIELD) and hasSetTextAction(),
            useUnmergedTree = true)
    priceNode.performTextInput("00a12b3!")
    // Enter valid fields so the button can be enabled
    composeRule
        .onNode(
            hasTestTag(C.AddListingScreenTags.TITLE_FIELD) and hasSetTextAction(),
            useUnmergedTree = true)
        .performTextInput("A")
    composeRule
        .onNode(
            hasTestTag(C.AddListingScreenTags.SIZE_FIELD) and hasSetTextAction(),
            useUnmergedTree = true)
        .performTextInput("10.0")
    composeRule
        .onNode(
            hasTestTag(C.AddListingScreenTags.DESC_FIELD) and hasSetTextAction(),
            useUnmergedTree = true)
        .performTextInput("Description")
    vm.setResidency("Vortex")
    // Select a residency (now required)
    // selectResidency("Vortex")

    // Button should be enabled with all valid fields including photo
    composeRule
        .onNodeWithTag(C.AddListingScreenTags.CONFIRM_BUTTON, useUnmergedTree = true)
        .assertIsEnabled()
  }

  @Test
  fun start_date_field_is_displayed() = run {
    runTest { switchToUser(FakeUser.FakeUser1) }
    setContentWith {}

    // Wait for the field to exist in the tree, then scroll to it (it may be below the fold)
    composeRule.waitUntil(5_000) {
      composeRule
          .onAllNodes(hasTestTag(C.AddListingScreenTags.START_DATE_FIELD), useUnmergedTree = true)
          .fetchSemanticsNodes()
          .isNotEmpty()
    }

    // Scroll to the field and assert it's displayed (performScrollTo waits internally)
    composeRule
        .onNodeWithTag(C.AddListingScreenTags.START_DATE_FIELD, useUnmergedTree = true)
        .performScrollTo()
        .assertIsDisplayed()
  }

  @Test
  fun clicking_start_date_opens_date_picker() = run {
    runTest { switchToUser(FakeUser.FakeUser1) }
    setContentWith {}

    // Wait for the field to exist, then scroll to it
    composeRule.waitUntil(5_000) {
      composeRule
          .onAllNodes(hasTestTag(C.AddListingScreenTags.START_DATE_FIELD), useUnmergedTree = true)
          .fetchSemanticsNodes()
          .isNotEmpty()
    }

    // Scroll to the field and click it (performScrollTo waits internally)
    composeRule
        .onNodeWithTag(C.AddListingScreenTags.START_DATE_FIELD, useUnmergedTree = true)
        .performScrollTo()
        .performClick()
    composeRule.waitForIdle()

    // Wait for date picker dialog to appear
    composeRule.waitUntil(5_000) {
      composeRule
          .onAllNodes(hasTestTag(C.CustomDatePickerDialogTags.OK_BUTTON), useUnmergedTree = true)
          .fetchSemanticsNodes()
          .isNotEmpty()
    }

    // Date picker dialog should be displayed
    composeRule
        .onNodeWithTag(C.CustomDatePickerDialogTags.OK_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed()
    composeRule
        .onNodeWithTag(C.CustomDatePickerDialogTags.CANCEL_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed()
  }

  @Test
  fun date_picker_can_be_dismissed() = run {
    runTest { switchToUser(FakeUser.FakeUser1) }
    setContentWith {}

    // Wait for the field to exist, then scroll to it
    composeRule.waitUntil(5_000) {
      composeRule
          .onAllNodes(hasTestTag(C.AddListingScreenTags.START_DATE_FIELD), useUnmergedTree = true)
          .fetchSemanticsNodes()
          .isNotEmpty()
    }

    // Scroll to the field and click it (performScrollTo waits internally)
    composeRule
        .onNodeWithTag(C.AddListingScreenTags.START_DATE_FIELD, useUnmergedTree = true)
        .performScrollTo()
        .performClick()
    composeRule.waitForIdle()

    // Wait for date picker dialog to appear
    composeRule.waitUntil(5_000) {
      composeRule
          .onAllNodes(hasTestTag(C.CustomDatePickerDialogTags.OK_BUTTON), useUnmergedTree = true)
          .fetchSemanticsNodes()
          .isNotEmpty()
    }

    composeRule
        .onNodeWithTag(C.CustomDatePickerDialogTags.CANCEL_BUTTON, useUnmergedTree = true)
        .performClick()
    composeRule.waitForIdle()

    // Wait for date picker to be dismissed
    composeRule.waitUntil(2_000) {
      composeRule
          .onAllNodes(hasTestTag(C.CustomDatePickerDialogTags.OK_BUTTON), useUnmergedTree = true)
          .fetchSemanticsNodes()
          .isEmpty()
    }
  }

  @Test
  fun selecting_date_updates_start_date_and_enables_submit() = run {
    runTest { switchToUser(FakeUser.FakeUser1) }
    val vm = createViewModelWithPhoto()
    setContentWithViewModel(vm) {}

    val confirmBtn =
        composeRule
            .onNodeWithTag(C.AddListingScreenTags.CONFIRM_BUTTON, useUnmergedTree = true)
            .assertExists()
    confirmBtn.assertIsNotEnabled()

    // Fill required fields
    composeRule
        .onNode(
            hasTestTag(C.AddListingScreenTags.TITLE_FIELD) and hasSetTextAction(),
            useUnmergedTree = true)
        .performTextInput("Cozy studio")
    selectResidency("Vortex")
    composeRule
        .onNode(
            hasTestTag(C.AddListingScreenTags.SIZE_FIELD) and hasSetTextAction(),
            useUnmergedTree = true)
        .performTextInput("25.0")
    composeRule
        .onNode(
            hasTestTag(C.AddListingScreenTags.PRICE_FIELD) and hasSetTextAction(),
            useUnmergedTree = true)
        .performTextInput("1200")
    composeRule
        .onNode(
            hasTestTag(C.AddListingScreenTags.DESC_FIELD) and hasSetTextAction(),
            useUnmergedTree = true)
        .performTextInput("Near EPFL")

    // Wait for the start date field to exist, then scroll to it
    composeRule.waitUntil(5_000) {
      composeRule
          .onAllNodes(hasTestTag(C.AddListingScreenTags.START_DATE_FIELD), useUnmergedTree = true)
          .fetchSemanticsNodes()
          .isNotEmpty()
    }

    // Scroll to the field and click it to open date picker
    composeRule
        .onNodeWithTag(C.AddListingScreenTags.START_DATE_FIELD, useUnmergedTree = true)
        .performScrollTo()
        .performClick()
    composeRule.waitForIdle()

    // Wait for date picker dialog to appear
    composeRule.waitUntil(5_000) {
      composeRule
          .onAllNodes(hasTestTag(C.CustomDatePickerDialogTags.OK_BUTTON), useUnmergedTree = true)
          .fetchSemanticsNodes()
          .isNotEmpty()
    }

    composeRule
        .onNodeWithTag(C.CustomDatePickerDialogTags.OK_BUTTON, useUnmergedTree = true)
        .performClick()
    composeRule.waitForIdle()

    // Button should now be enabled with all fields including date filled
    confirmBtn.assertIsEnabled()
  }

  @Test
  fun selecting_private_accommodation_shows_custom_location_button_and_dialog() = run {
    runTest { switchToUser(FakeUser.FakeUser1) }
    setContentWith {}

    selectResidency("Private Accommodation")

    composeRule
        .onNodeWithTag(C.AddListingScreenTags.CUSTOM_LOCATION_BUTTON, useUnmergedTree = true)
        .performScrollTo()
        .assertIsDisplayed()
        .performClick()
    composeRule.waitUntil(5_000) {
      composeRule
          .onAllNodes(hasTestTag(C.CustomLocationDialogTags.DIALOG_TITLE), useUnmergedTree = true)
          .fetchSemanticsNodes()
          .isNotEmpty()
    }

    composeRule
        .onNodeWithTag(C.CustomLocationDialogTags.CONFIRM_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed()
  }

  @Test
  fun ui_guest_user_sees_disabled_button_and_warning() = run {
    runTest { signInAnonymous() }
    setContentWith {}
    composeRule
        .onNode(
            hasTestTag(C.AddListingScreenTags.TITLE_FIELD) and hasSetTextAction(),
            useUnmergedTree = true)
        .performTextInput("Guest Attempt")
    selectResidency("Vortex")
    composeRule
        .onNode(
            hasTestTag(C.AddListingScreenTags.SIZE_FIELD) and hasSetTextAction(),
            useUnmergedTree = true)
        .performTextInput("20.0")
    composeRule
        .onNode(
            hasTestTag(C.AddListingScreenTags.PRICE_FIELD) and hasSetTextAction(),
            useUnmergedTree = true)
        .performTextInput("1000")
    composeRule
        .onNode(
            hasTestTag(C.AddListingScreenTags.DESC_FIELD) and hasSetTextAction(),
            useUnmergedTree = true)
        .performTextInput("Guest Desc")
    val confirmBtn =
        composeRule
            .onNodeWithTag(C.AddListingScreenTags.CONFIRM_BUTTON, useUnmergedTree = true)
            .assertExists()
    confirmBtn.assertIsNotEnabled()
    composeRule
        .onNodeWithTag(C.AddListingScreenTags.ERROR_MESSAGE, useUnmergedTree = true)
        .assertIsDisplayed()
  }

  @Test
  fun multiple_rapid_clicks_creates_only_one_listing() = run {
    runTest { switchToUser(FakeUser.FakeUser1) }
    var submissionCount = 0
    val vm = createViewModelWithPhoto()
    setContentWithViewModel(vm) { submissionCount++ }

    // Fill all required fields
    composeRule
        .onNode(
            hasTestTag(C.AddListingScreenTags.TITLE_FIELD) and hasSetTextAction(),
            useUnmergedTree = true)
        .performTextInput("Test listing")
    selectResidency("Vortex")
    composeRule
        .onNode(
            hasTestTag(C.AddListingScreenTags.SIZE_FIELD) and hasSetTextAction(),
            useUnmergedTree = true)
        .performTextInput("25.0")
    composeRule
        .onNode(
            hasTestTag(C.AddListingScreenTags.PRICE_FIELD) and hasSetTextAction(),
            useUnmergedTree = true)
        .performTextInput("1200")
    composeRule
        .onNode(
            hasTestTag(C.AddListingScreenTags.DESC_FIELD) and hasSetTextAction(),
            useUnmergedTree = true)
        .performTextInput("Test desc")

    val confirmBtn =
        composeRule
            .onNodeWithTag(C.AddListingScreenTags.CONFIRM_BUTTON, useUnmergedTree = true)
            .assertExists()
            .assertIsEnabled()

    // Rapidly click the button multiple times
    confirmBtn.performClick()
    confirmBtn.performClick()
    confirmBtn.performClick()

    // Allow submissions to process
    runBlocking { delay(500) }

    // Verify only one submission was made
    assertEquals("Only one listing should be created", 1, submissionCount)
    runTest { assertEquals("Only one listing should be in Firestore", 1, getRentalListingCount()) }
  }

  @Test
  fun button_is_disabled_during_submission() = run {
    runTest { switchToUser(FakeUser.FakeUser1) }
    val vm = createViewModelWithPhoto()
    setContentWithViewModel(vm) {}

    // Fill all required fields
    composeRule
        .onNode(
            hasTestTag(C.AddListingScreenTags.TITLE_FIELD) and hasSetTextAction(),
            useUnmergedTree = true)
        .performTextInput("Test listing")
    selectResidency("Vortex")
    composeRule
        .onNode(
            hasTestTag(C.AddListingScreenTags.SIZE_FIELD) and hasSetTextAction(),
            useUnmergedTree = true)
        .performTextInput("25.0")
    composeRule
        .onNode(
            hasTestTag(C.AddListingScreenTags.PRICE_FIELD) and hasSetTextAction(),
            useUnmergedTree = true)
        .performTextInput("1200")
    composeRule
        .onNode(
            hasTestTag(C.AddListingScreenTags.DESC_FIELD) and hasSetTextAction(),
            useUnmergedTree = true)
        .performTextInput("Test desc")

    val confirmBtn =
        composeRule
            .onNodeWithTag(C.AddListingScreenTags.CONFIRM_BUTTON, useUnmergedTree = true)
            .assertExists()
            .assertIsEnabled()

    // Click the button - it should become disabled immediately
    confirmBtn.performClick()

    // Give a small delay for the state to update
    runBlocking { delay(50) }

    // Button should be disabled during submission
    composeRule
        .onNodeWithTag(C.AddListingScreenTags.CONFIRM_BUTTON, useUnmergedTree = true)
        .assertIsNotEnabled()
  }

  @Test
  fun fullScreenIsPresent() {
    val photo = Photo(File.createTempFile(FAKE_NAME, FAKE_SUFFIX).toUri(), FAKE_FILE_NAME)
    val vm =
        AddListingViewModel(
            photoRepositoryLocal =
                FakePhotoRepository.commonLocalRepo(
                    onRetrieve = { photo }, onUpload = {}, onDelete = true))
    runTest { vm.addPhoto(photo) }
    composeRule.setContent {
      AddListingScreen(onConfirm = {}, onBack = {}, addListingViewModel = vm)
    }
    composeRule.waitForIdle()

    // Go to the photo preview
    composeRule.onNodeWithTag(C.AddPhotoButtonTags.BUTTON).performScrollTo()
    composeRule.waitUntil("The last added image is not shown", 5_000) {
      composeRule
          .onNodeWithTag(C.ImageGridTags.imageTag(photo.image), useUnmergedTree = true)
          .isDisplayed()
    }
    // Click on a photo to display in full screen
    composeRule
        .onNodeWithTag(C.ImageGridTags.imageTag(photo.image), useUnmergedTree = true)
        .performScrollTo()
        .performClick()

    composeRule.waitForIdle()
    // Check image is shown in full screen
    composeRule.waitUntil("The clicked image is not shown in full screen", 5_000) {
      composeRule
          .onNodeWithTag(C.FullScreenImageViewerTags.imageTag(photo.image), useUnmergedTree = true)
          .isDisplayed()
    }

    // Check that go back to the add listing page
    composeRule
        .onNodeWithTag(C.FullScreenImageViewerTags.DELETE_BUTTON, useUnmergedTree = true)
        .performClick()
    composeRule.waitUntil(
        "The listing page is not shown after leaving the full screen mode", 5_000) {
          composeRule.onNodeWithTag(C.AddPhotoButtonTags.BUTTON).isDisplayed()
        }
  }
}
