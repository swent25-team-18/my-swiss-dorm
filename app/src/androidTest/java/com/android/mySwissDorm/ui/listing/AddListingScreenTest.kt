package com.android.mySwissDorm.ui.listing

import AddListingScreen
import androidx.activity.ComponentActivity
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.assertIsEnabled
import androidx.compose.ui.test.assertIsNotEnabled
import androidx.compose.ui.test.hasSetTextAction
import androidx.compose.ui.test.hasTestTag
import androidx.compose.ui.test.hasText
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithTag
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.compose.ui.test.performScrollTo
import androidx.compose.ui.test.performTextInput
import androidx.test.platform.app.InstrumentationRegistry
import com.android.mySwissDorm.model.map.Location
import com.android.mySwissDorm.model.photo.PhotoRepositoryProvider
import com.android.mySwissDorm.model.rental.RentalListingRepositoryFirestore
import com.android.mySwissDorm.model.rental.RentalListingRepositoryProvider
import com.android.mySwissDorm.model.residency.ResidenciesRepositoryFirestore
import com.android.mySwissDorm.model.residency.ResidenciesRepositoryProvider
import com.android.mySwissDorm.model.residency.Residency
import com.android.mySwissDorm.resources.C
import com.android.mySwissDorm.utils.FakeUser
import com.android.mySwissDorm.utils.FirebaseEmulator
import com.android.mySwissDorm.utils.FirestoreTest
import java.net.URL
import kotlinx.coroutines.delay
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.test.runTest
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Assert.assertNotNull
import org.junit.Before
import org.junit.Rule
import org.junit.Test

/**
 * Tests focused on the AddListingScreen UI with the new centralized InputSanitizers. We verify: (1)
 * button enablement, (2) inline error for size format, (3) Firestore write.
 */
class AddListingScreenTest : FirestoreTest() {
  @get:Rule val composeRule = createAndroidComposeRule<ComponentActivity>()

  override fun createRepositories() {
    PhotoRepositoryProvider.initialize(InstrumentationRegistry.getInstrumentation().context)
    RentalListingRepositoryProvider.repository =
        RentalListingRepositoryFirestore(FirebaseEmulator.firestore)
    ResidenciesRepositoryProvider.repository =
        ResidenciesRepositoryFirestore(FirebaseEmulator.firestore)
  }

  private fun setContentWith(onConfirmCapture: (String) -> Unit = {}) {
    composeRule.setContent {
      AddListingScreen(
          onConfirm = { added -> onConfirmCapture(added.uid) }, onBack = { /* no-op */})
    }
  }

  // generated by AI
  @Before
  override fun setUp() {
    runTest {
      super.setUp()
      switchToUser(FakeUser.FakeUser1)
      ResidenciesRepositoryProvider.repository.addResidency(
          Residency(
              name = "Vortex",
              description = "Test residency",
              location = Location(name = "Vortex", latitude = 46.52, longitude = 6.57),
              city = "Lausanne",
              email = null,
              phone = null,
              website = URL("https://example.com")))

      // Seed Private Accommodation so we can test the custom-location path
      ResidenciesRepositoryProvider.repository.addResidency(
          Residency(
              name = "Private Accommodation",
              description = "Private flat",
              location = Location(name = "Lausanne centre", latitude = 46.52, longitude = 6.63),
              city = "Lausanne",
              email = null,
              phone = null,
              website = null))

      // Wait for the residencies to be persisted to Firestore
      delay(500)
    }
  }

  // Helper function to select a residency from the dropdown
  private fun selectResidency(residencyName: String) {
    // Wait for the "Residency Name" label to appear (field exists in UI)
    composeRule.waitUntil(5_000) {
      composeRule
          .onAllNodes(hasText("Residency Name"), useUnmergedTree = true)
          .fetchSemanticsNodes()
          .isNotEmpty()
    }

    // Wait for residencies to load - try to open dropdown until menu appears with residency
    // We'll attempt to click the field and check if menu opens with options
    var dropdownOpened = false
    var attempts = 0
    while (!dropdownOpened && attempts < 30) {
      try {
        // Try clicking on "Select residency" if it exists, otherwise try clicking on the label area
        val hasSelectResidency =
            composeRule
                .onAllNodes(hasText("Select residency"), useUnmergedTree = true)
                .fetchSemanticsNodes()
                .isNotEmpty()

        if (hasSelectResidency) {
          composeRule.onNodeWithText("Select residency", useUnmergedTree = true).performClick()
        } else {
          // If "Select residency" doesn't exist yet, try clicking on "Residency Name" label
          // The field should still be clickable even if value isn't visible
          composeRule.onNodeWithText("Residency Name", useUnmergedTree = true).performClick()
        }
        composeRule.waitForIdle()

        // Check if menu opened by looking for residency name in dropdown menu
        val menuOpen =
            composeRule
                .onAllNodes(hasText(residencyName), useUnmergedTree = true)
                .fetchSemanticsNodes()
                .size >= 2 // Should appear at least in menu (and maybe field if already selected)

        if (menuOpen) {
          dropdownOpened = true
        }
      } catch (_: Exception) {
        // Field might not be ready yet, wait and try again
      }
      attempts++
      if (!dropdownOpened && attempts < 30) {
        composeRule.waitForIdle()
        // Small delay to allow residencies to load
        Thread.sleep(200)
      }
    }

    if (!dropdownOpened) {
      // Final attempt with longer wait - residencies should be loaded by now
      composeRule.waitUntil(5_000) {
        val hasField =
            composeRule
                .onAllNodes(
                    hasText("Select residency") or hasText("Residency Name"),
                    useUnmergedTree = true)
                .fetchSemanticsNodes()
                .isNotEmpty()
        if (hasField) {
          val fieldNodes =
              composeRule.onAllNodes(
                  hasText("Select residency") or hasText("Residency Name"), useUnmergedTree = true)
          fieldNodes[0].performClick()
          composeRule.waitForIdle()
          composeRule
              .onAllNodes(hasText(residencyName), useUnmergedTree = true)
              .fetchSemanticsNodes()
              .isNotEmpty()
        } else {
          false
        }
      }
    }

    // Now click on the residency name in the dropdown menu
    composeRule.waitUntil(5_000) {
      composeRule
          .onAllNodes(hasText(residencyName), useUnmergedTree = true)
          .fetchSemanticsNodes()
          .isNotEmpty()
    }

    val menuItems = composeRule.onAllNodes(hasText(residencyName), useUnmergedTree = true)
    menuItems[0].performClick()
    composeRule.waitForIdle()
  }

  @After
  override fun tearDown() {
    super.tearDown()
  }

  @Test
  fun ui_button_disabled_until_all_fields_valid_then_writes() = run {
    runTest { switchToUser(FakeUser.FakeUser1) }
    var capturedUid: String? = null
    setContentWith { uid -> capturedUid = uid }

    val confirmBtn = composeRule.onNodeWithText("Confirm listing").assertExists()
    confirmBtn.assertIsNotEnabled()

    // Fill fields with VALID values respecting new validators (size requires one decimal).
    composeRule.onNode(hasText("Title") and hasSetTextAction()).performTextInput("Cozy studio")
    selectResidency("Vortex")
    composeRule.onNode(hasText("Room size (m²)") and hasSetTextAction()).performTextInput("25.0")
    composeRule
        .onNode(hasText("Price (CHF / month)") and hasSetTextAction())
        .performTextInput("1200")
    composeRule.onNode(hasText("Description") and hasSetTextAction()).performTextInput("Near EPFL")

    // Button should now enable
    confirmBtn.assertIsEnabled()
    confirmBtn.performClick()

    // Allow VM coroutine to persist
    runBlocking { delay(250) }

    runTest {
      assertEquals("UI should insert one listing into Firestore", 1, getRentalListingCount())
    }
    assertNotNull("onConfirm must be called with the created listing", capturedUid)
  }

  @Test
  fun ui_inline_error_shown_for_size_without_decimal_and_blocks_submit() = run {
    runTest { switchToUser(FakeUser.FakeUser2) }
    setContentWith {}

    val confirmBtn = composeRule.onNodeWithText("Confirm listing").assertExists()

    composeRule.onNode(hasText("Title") and hasSetTextAction()).performTextInput("X")
    composeRule.onNode(hasText("Description") and hasSetTextAction()).performTextInput("Y")

    // Entering 1000 (no decimal) is invalid per validateFinal (must have exactly one decimal)
    composeRule.onNode(hasText("Room size (m²)") and hasSetTextAction()).performTextInput("1000")

    // Price is fine but we keep it blank to ensure the button remains disabled
    // (even with price filled size error must still block submit)
    confirmBtn.assertIsNotEnabled()

    runTest { assertEquals(0, getRentalListingCount()) }
  }

  @Test
  fun ui_price_typing_filters_to_digits_and_caps_value_visually() = run {
    runTest { switchToUser(FakeUser.FakeUser1) }
    setContentWith {}

    // Enter noisy input; sanitizer should filter to digits only and drop leading zeros.
    val priceNode = composeRule.onNode(hasText("Price (CHF / month)") and hasSetTextAction())
    priceNode.performTextInput("00a12b3!")
    // Enter minimal other fields so the button remains disabled (size missing decimal)
    composeRule.onNode(hasText("Title") and hasSetTextAction()).performTextInput("A")
    composeRule.onNode(hasText("Room size (m²)") and hasSetTextAction()).performTextInput("10")
    // Select a residency (now required)
    selectResidency("Vortex")

    // Still disabled because size invalid (no decimal) and description empty
    composeRule.onNodeWithText("Confirm listing").assertIsEnabled()
  }

  @Test
  fun start_date_field_is_displayed() = run {
    runTest { switchToUser(FakeUser.FakeUser1) }
    setContentWith {}

    // Wait for the field to exist in the tree, then scroll to it (it may be below the fold)
    composeRule.waitUntil(5_000) {
      composeRule
          .onAllNodes(hasTestTag(C.AddListingScreenTags.START_DATE_FIELD), useUnmergedTree = true)
          .fetchSemanticsNodes()
          .isNotEmpty()
    }

    // Scroll to the field and assert it's displayed (performScrollTo waits internally)
    composeRule
        .onNodeWithTag(C.AddListingScreenTags.START_DATE_FIELD, useUnmergedTree = true)
        .performScrollTo()
        .assertIsDisplayed()
    composeRule.onNodeWithText("Start Date", useUnmergedTree = true).assertIsDisplayed()
  }

  @Test
  fun clicking_start_date_opens_date_picker() = run {
    runTest { switchToUser(FakeUser.FakeUser1) }
    setContentWith {}

    // Wait for the field to exist, then scroll to it
    composeRule.waitUntil(5_000) {
      composeRule
          .onAllNodes(hasTestTag(C.AddListingScreenTags.START_DATE_FIELD), useUnmergedTree = true)
          .fetchSemanticsNodes()
          .isNotEmpty()
    }

    // Scroll to the field and click it (performScrollTo waits internally)
    composeRule
        .onNodeWithTag(C.AddListingScreenTags.START_DATE_FIELD, useUnmergedTree = true)
        .performScrollTo()
        .performClick()
    composeRule.waitForIdle()

    // Wait for date picker dialog to appear
    composeRule.waitUntil(5_000) {
      composeRule
          .onAllNodes(hasTestTag(C.CustomDatePickerDialogTags.OK_BUTTON), useUnmergedTree = true)
          .fetchSemanticsNodes()
          .isNotEmpty()
    }

    // Date picker dialog should be displayed
    composeRule
        .onNodeWithTag(C.CustomDatePickerDialogTags.OK_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed()
    composeRule
        .onNodeWithTag(C.CustomDatePickerDialogTags.CANCEL_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed()
  }

  @Test
  fun date_picker_can_be_dismissed() = run {
    runTest { switchToUser(FakeUser.FakeUser1) }
    setContentWith {}

    // Wait for the field to exist, then scroll to it
    composeRule.waitUntil(5_000) {
      composeRule
          .onAllNodes(hasTestTag(C.AddListingScreenTags.START_DATE_FIELD), useUnmergedTree = true)
          .fetchSemanticsNodes()
          .isNotEmpty()
    }

    // Scroll to the field and click it (performScrollTo waits internally)
    composeRule
        .onNodeWithTag(C.AddListingScreenTags.START_DATE_FIELD, useUnmergedTree = true)
        .performScrollTo()
        .performClick()
    composeRule.waitForIdle()

    // Wait for date picker dialog to appear
    composeRule.waitUntil(5_000) {
      composeRule
          .onAllNodes(hasTestTag(C.CustomDatePickerDialogTags.OK_BUTTON), useUnmergedTree = true)
          .fetchSemanticsNodes()
          .isNotEmpty()
    }

    composeRule
        .onNodeWithTag(C.CustomDatePickerDialogTags.CANCEL_BUTTON, useUnmergedTree = true)
        .performClick()
    composeRule.waitForIdle()

    // Wait for date picker to be dismissed
    composeRule.waitUntil(2_000) {
      composeRule
          .onAllNodes(hasTestTag(C.CustomDatePickerDialogTags.OK_BUTTON), useUnmergedTree = true)
          .fetchSemanticsNodes()
          .isEmpty()
    }
  }

  @Test
  fun selecting_date_updates_start_date_and_enables_submit() = run {
    runTest { switchToUser(FakeUser.FakeUser1) }
    setContentWith {}

    val confirmBtn = composeRule.onNodeWithText("Confirm listing").assertExists()
    confirmBtn.assertIsNotEnabled()

    // Fill required fields
    composeRule.onNode(hasText("Title") and hasSetTextAction()).performTextInput("Cozy studio")
    selectResidency("Vortex")
    composeRule.onNode(hasText("Room size (m²)") and hasSetTextAction()).performTextInput("25.0")
    composeRule
        .onNode(hasText("Price (CHF / month)") and hasSetTextAction())
        .performTextInput("1200")
    composeRule.onNode(hasText("Description") and hasSetTextAction()).performTextInput("Near EPFL")

    // Wait for the start date field to exist, then scroll to it
    composeRule.waitUntil(5_000) {
      composeRule
          .onAllNodes(hasTestTag(C.AddListingScreenTags.START_DATE_FIELD), useUnmergedTree = true)
          .fetchSemanticsNodes()
          .isNotEmpty()
    }

    // Scroll to the field and click it to open date picker
    composeRule
        .onNodeWithTag(C.AddListingScreenTags.START_DATE_FIELD, useUnmergedTree = true)
        .performScrollTo()
        .performClick()
    composeRule.waitForIdle()

    // Wait for date picker dialog to appear
    composeRule.waitUntil(5_000) {
      composeRule
          .onAllNodes(hasTestTag(C.CustomDatePickerDialogTags.OK_BUTTON), useUnmergedTree = true)
          .fetchSemanticsNodes()
          .isNotEmpty()
    }

    composeRule
        .onNodeWithTag(C.CustomDatePickerDialogTags.OK_BUTTON, useUnmergedTree = true)
        .performClick()
    composeRule.waitForIdle()

    // Button should now be enabled with all fields including date filled
    confirmBtn.assertIsEnabled()
  }

  @Test
  fun selecting_private_accommodation_shows_custom_location_button_and_dialog() = run {
    runTest { switchToUser(FakeUser.FakeUser1) }
    setContentWith {}

    selectResidency("Private Accommodation")

    composeRule
        .onNodeWithTag(C.AddListingScreenTags.CUSTOM_LOCATION_BUTTON, useUnmergedTree = true)
        .performScrollTo()
        .assertIsDisplayed()
        .performClick()
    composeRule.waitUntil(5_000) {
      composeRule
          .onAllNodes(hasTestTag(C.CustomLocationDialogTags.DIALOG_TITLE), useUnmergedTree = true)
          .fetchSemanticsNodes()
          .isNotEmpty()
    }

    composeRule
        .onNodeWithTag(C.CustomLocationDialogTags.CONFIRM_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed()
  }

  @Test
  fun ui_guest_user_sees_disabled_button_and_warning() = run {
    runTest { signInAnonymous() }
    setContentWith {}
    composeRule.onNode(hasText("Title") and hasSetTextAction()).performTextInput("Guest Attempt")
    selectResidency("Vortex")
    composeRule.onNode(hasText("Room size (m²)") and hasSetTextAction()).performTextInput("20.0")
    composeRule
        .onNode(hasText("Price (CHF / month)") and hasSetTextAction())
        .performTextInput("1000")
    composeRule.onNode(hasText("Description") and hasSetTextAction()).performTextInput("Guest Desc")
    val confirmBtn = composeRule.onNodeWithText("Confirm listing").assertExists()
    confirmBtn.assertIsNotEnabled()
    composeRule
        .onNodeWithText(
            "Please complete all required fields (valid size, price, and starting date) or Sign-in if you're a guest.")
        .assertIsDisplayed()
  }
}
