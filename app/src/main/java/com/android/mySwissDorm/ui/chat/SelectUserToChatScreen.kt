package com.android.mySwissDorm.ui.chat

import android.util.Log
import android.widget.Toast
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Search
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import coil.compose.AsyncImage
import com.android.mySwissDorm.R
import com.android.mySwissDorm.model.chat.StreamChatProvider
import com.android.mySwissDorm.model.profile.ProfileRepositoryProvider
import com.android.mySwissDorm.ui.theme.BackGroundColor
import com.android.mySwissDorm.ui.theme.Dimens
import com.android.mySwissDorm.ui.theme.LightGray1
import com.android.mySwissDorm.ui.theme.MainColor
import com.android.mySwissDorm.ui.theme.OutlineColor
import com.google.firebase.auth.FirebaseAuth
import kotlinx.coroutines.launch

/**
 * Screen for selecting a user to start a new chat conversation.
 *
 * This screen displays a searchable list of all users in the system, allowing the current user to
 * select someone to start a new chat with. When a user is selected, a new Stream Chat channel is
 * created between the current user and the selected user.
 *
 * **Features:**
 * - Displays all users except the current user and blocked users
 * - Search functionality to filter users by name
 * - Shows user avatars and names in a scrollable list
 * - Automatically creates a Stream Chat channel when a user is selected
 * - Shows loading state while fetching users
 * - Shows empty state when no users are found or match the search query
 * - Displays error messages via Toast if channel creation fails
 *
 * **User Filtering:**
 * - Excludes the current authenticated user
 * - Excludes users that have been blocked by the current user
 * - Users are sorted alphabetically by name
 *
 * **Channel Creation:**
 * - Creates a new Stream Chat channel of type "messaging"
 * - Channel ID is auto-generated by Stream based on member IDs
 * - Both users are added as members of the channel
 * - Channel name is set to the selected user's display name
 *
 * **State Management:**
 * - Loads users once when the screen is composed using [LaunchedEffect]
 * - Filters users in real-time based on the search query
 * - Manages loading and error states
 *
 * **Authentication:**
 * - Requires the user to be signed in (non-anonymous)
 * - Shows a sign-in prompt if the user is not authenticated
 *
 * @param onBackClick Callback invoked when the back button is clicked
 * @param onUserSelected Callback invoked when a user is selected and a chat channel is created.
 *   Receives the channel CID (Channel ID) in the format "channelType:channelId" which can be used
 *   to navigate to the chat screen.
 * @param modifier Modifier to be applied to the screen
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SelectUserToChatScreen(
    onBackClick: () -> Unit,
    onUserSelected: (String) -> Unit,
    modifier: Modifier = Modifier
) {

  val coroutineScope = rememberCoroutineScope()
  val currentUser = FirebaseAuth.getInstance().currentUser
  val context = LocalContext.current

  if (currentUser == null) {
    Box(modifier = modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
      Text(stringResource(R.string.view_user_profile_not_signed_in))
    }
    return
  }

  var users by remember { mutableStateOf<List<UserItem>>(emptyList()) }
  var isLoading by remember { mutableStateOf(true) }
  var searchQuery by remember { mutableStateOf("") }
  var blockedUserIds by remember { mutableStateOf<List<String>>(emptyList()) }

  // Load users
  LaunchedEffect(Unit) {
    try {
      // Get blocked users
      blockedUserIds = ProfileRepositoryProvider.repository.getBlockedUserIds(currentUser.uid)

      // Get all profiles
      val profiles = ProfileRepositoryProvider.repository.getAllProfile()

      // Filter out current user and blocked users, then map to UserItem
      users =
          profiles
              .filter { it.ownerId != currentUser.uid && !blockedUserIds.contains(it.ownerId) }
              .map { profile ->
                UserItem(
                    userId = profile.ownerId,
                    name = "${profile.userInfo.name} ${profile.userInfo.lastName}".trim(),
                    imageUrl = "test")
              }
              .sortedBy { it.name }

      isLoading = false
    } catch (e: Exception) {
      Log.e("SelectUserToChat", "Error loading users", e)
      Toast.makeText(
              context,
              context.getString(R.string.failed_to_load_user) + ": ${e.message}",
              Toast.LENGTH_SHORT)
          .show()
      isLoading = false
    }
  }

  // Filter users based on search query
  val filteredUsers =
      remember(users, searchQuery) {
        if (searchQuery.isBlank()) {
          users
        } else {
          users.filter { it.name.contains(searchQuery, ignoreCase = true) }
        }
      }

  Scaffold(
      topBar = {
        TopAppBar(
            title = { Text(stringResource(R.string.new_chat)) },
            navigationIcon = {
              IconButton(onClick = onBackClick) {
                Icon(Icons.Default.ArrowBack, contentDescription = "Back")
              }
            },
            colors =
                TopAppBarDefaults.topAppBarColors(
                    containerColor = MainColor,
                    titleContentColor = BackGroundColor,
                    navigationIconContentColor = BackGroundColor))
      }) { paddingValues ->
        Column(modifier = modifier.fillMaxSize().padding(paddingValues)) {
          // Search bar
          OutlinedTextField(
              value = searchQuery,
              onValueChange = { searchQuery = it },
              placeholder = { stringResource(R.string.search_users) },
              leadingIcon = { Icon(Icons.Default.Search, contentDescription = null) },
              modifier =
                  Modifier.fillMaxWidth()
                      .padding(horizontal = Dimens.PaddingDefault, vertical = Dimens.PaddingSmall),
              singleLine = true,
              colors =
                  OutlinedTextFieldDefaults.colors(
                      focusedBorderColor = MainColor, unfocusedBorderColor = OutlineColor))

          // User list
          if (isLoading) {
            Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
              CircularProgressIndicator(color = MainColor)
            }
          } else if (filteredUsers.isEmpty()) {
            Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
              Text(
                  text =
                      if (searchQuery.isBlank()) stringResource(R.string.no_users_found)
                      else stringResource(R.string.no_users_match_your_search),
                  style = MaterialTheme.typography.bodyLarge,
                  color = LightGray1)
            }
          } else {
            LazyColumn {
              items(filteredUsers) { user ->
                UserListItem(
                    user = user,
                    onClick = {
                      coroutineScope.launch {
                        try {
                          // Create or get existing channel with this user
                          val channelCid =
                              StreamChatProvider.createChannel(
                                  channelType = "messaging",
                                  channelId = null, // Let Stream generate it
                                  memberIds = listOf(currentUser.uid, user.userId),
                                  extraData = mapOf("name" to user.name))
                          Toast.makeText(context, "Chat created!", Toast.LENGTH_SHORT).show()
                          onUserSelected(channelCid)
                        } catch (e: Exception) {
                          Log.e("SelectUserToChat", "Error creating channel", e)
                          Toast.makeText(
                                  context,
                                  context.getString(R.string.failed_to_create_chat) +
                                      ":${e.message}",
                                  Toast.LENGTH_SHORT)
                              .show()
                        }
                      }
                    })
              }
            }
          }
        }
      }
}

/**
 * Data class representing a user in the selection list.
 *
 * @param userId The unique user ID
 * @param name The user's display name (first name + last name)
 * @param imageUrl Optional profile image URL
 */
private data class UserItem(val userId: String, val name: String, val imageUrl: String?)

/**
 * Composable for displaying a single user in the selection list.
 *
 * Shows the user's avatar (or a default image) and name. The entire row is clickable to select the
 * user and create a chat channel.
 *
 * @param user The [UserItem] to display
 * @param onClick Callback invoked when the user item is clicked
 * @param modifier Modifier to be applied to the item
 */
@Composable
private fun UserListItem(user: UserItem, onClick: () -> Unit, modifier: Modifier = Modifier) {
  Row(
      modifier =
          modifier
              .fillMaxWidth()
              .clickable(onClick = onClick)
              .padding(horizontal = Dimens.PaddingDefault, vertical = Dimens.PaddingMedium),
      verticalAlignment = Alignment.CenterVertically) {
        // Avatar
        AsyncImage(
            model = user.imageUrl ?: "https://bit.ly/2TIt8NR",
            contentDescription = user.name,
            modifier = Modifier.size(Dimens.ImageSizeAvatar).clip(CircleShape),
            contentScale = ContentScale.Crop)

        Spacer(modifier = Modifier.width(Dimens.SpacingLarge))

        // Name
        Text(
            text = user.name,
            style = MaterialTheme.typography.titleMedium,
            fontWeight = FontWeight.Normal,
            maxLines = 1,
            overflow = TextOverflow.Ellipsis,
            modifier = Modifier.weight(1f))
      }

  HorizontalDivider()
}
